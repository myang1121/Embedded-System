# Embedded-System
This repository contains some of my lab files from my university Embedded System course during my Junior Spring semester.

## Morse Code w/ Assembly Programming
The purpose of this lab is to develop assembly language programs for the FRDM-KL46Z microcontroller, which uses an ARM Cortex-M0+ processor operating in Thumb mode (ARM v6-M instruction set). This lab provided hands-on experience with the ARM instruction set and reinforced the importance of following proper ARM calling conventions—especially with regard to saving and restoring registers on the stack. 

In Part 1, I wrote an assembly program that reads a value from register R0 and uses the red LED on the microcontroller to signal the corresponding Morse code digit. Morse code represents numbers using a combination of dots and dashes, where a dot is signaled by turning the LED on for approximately 0.3 - 0.4 seconds (with a similar off delay), and a dash is signaled by keeping the LED on for three times that duration. The challenge was to implement these precise delays. 

Part 2 builds on Part 1 by encapsulating the Morse code logic in a function called morse_digit() that adheres to ARM calling conventions, making it linkable with a C program. In this part, I also developed test cases to ensure that morse_digit() correctly handles all valid inputs (0 through 9). I learned that it is crucial to manage the stack properly—using PUSH and POP—to prevent interference between consecutive function calls. 

In Part 3, I implemented a recursive Fibonacci function that mirrors the provided C-code structure. This function makes two recursive calls per non-base case and uses proper stack management to preserve registers during recursion. The result from fib() is then displayed using morse_digit(), demonstrating the integration of both parts of the lab. 

This exercise required me to visualize the stack and to carefully plan when and what to PUSH and POP during recursive calls. This lab deepened my understanding of ARM assembly programming, precise timing for hardware control, how to debug assembly programs using tests and the debug feature of MCUXpresso, and the importance of following calling conventions to ensure reliable function calls and recursion.

## LED Library using I/O and Interrupts
The purpose of this lab is to control LEDs through memory-mapped I/O, polling, and interrupts on the FRDM-KL46Z board. 

Part 1 involves writing an LED library to control the red, green, and blue LEDs of LED0. In this part, I implemented the functions described in the header file led.h within led.c, including toggling, turning on, turning off, and turning all LEDs off. 

Part 2 focuses on extending the LED library to control multiple serial LEDs. Due to tight timing constraints, outputting the bit-stream for setting a single LED is implemented in Assembly. 

Part 3 implements a polling-based approach to check if a peripheral timer has finished. The periodic interval timer (PIT[0]) was used. I accessed the TCTRL, TFLG, LDV AL, and MCR registers to implement polling. 

Part 4 introduces interrupts and handles the PIT_IRQHandler. The red LED flashes approximately once per second, while the green LED flashes for about 1/10th of a second once every second. 

Part 5 extends the functionality of LED0, allowing it to display RGB values using software. The PIT/ISR was used to ensure the LED continues displaying color while the processor runs other code. 

Through this lab, I gained practical experience with GPIO configuration, cycle-accurate timing in assembly, interrupt service routines (ISRs), and hardware register management.

## Concurrency
The high level architecture utilized the given components: utils.c for manipulating the built in LEDs on the FRDM board, concur.c that provided functionality for allocating and deallocating space on the stack for processes, starting processes, and adjacent operations. Process.h was ,modified to include the process _ state struct that contained a size, stack pointer, current stack pointer and next pointer to specify size allocation, moved stack pointer, original stack pointer, and next pointer for enqueue/dequeue respectively. Three functions were then created for process.c for creating, starting, and selecting processes. These three functions would be called by users of the concurrency package and would manipulate the process queue. The process.c file manipulates the process state through the struct process state outlined in _ process.h to employ a linked list data structure to manage multiple processes as shown in figure 1, with each process represented as nodes that can be added or removed from the queue as needed. To ensure smooth execution and process management, various scenarios and edge cases that require meticulous implementation were accounted for.

In process.c three core functions that had the role of creating, starting, and selecting processes were implement. The function process _ create creates a process that starts at function f with initial stack size n. When creating a process, process stack init function was utilized to allocate stack _ _ space for a stack pointer. Memory was allocated for the process itself, initialize the new process fields, then added to the queue using the given enqueue function that ensures the process is properly initialized and added to the queue for execution. The function process _ start(void), sets up a period interrupt to be generated using the PIT interrupt with the interrupt handler being implemented in the given 3140.s assembly code, then ensures all data structures are correctly initialized, and end with a call to process _ begin(), initiating the first process. To do this, I followed the steps of enabling the clock, enabling the PIT, configuring the PIT with a set load value, and enabling the timer and interrupt before calling process _ begin(). The function process _ select (unsigned int* cursp), selects the next ready process, where cursp is the current stack pointer for the process that was just pre-empted and has the context at the top of the stack. During the process selection, I deallocate stack space from the current process when finished and set the current process to the next process waiting in the queue as shown in figure 2. The function ensures that the process queue is managed and executed in the correct order and that completed processes are properly deallocated. Throughout these functions, the given two helper functions enqueue() and dequeue() manage the process queue by adding new processes to the end of the queue and removing processes from the front of the queue respectively to ensure in order fair execution (round robin). Assumptions that were made were based on the size of the heap and how many processes with given stack sizes can be held. For example the program would fail if you are adding roughly more than or equal to 2 kilobytes of storage onto the heap (e.g. 4 processes, each 0.5 KB, 10 processes, each 0.2 KB, etc.).

## Locks
The purpose of this lab is to implement 2 types of locks using the FRDM-KL46Z microcontroller. When a process calls a lock and finds another process in the critical section (lock unavailable), spinlock causes the process to enter a busy-wait, constantly checking (spinning) until the lock becomes available. A blocking lock requires the implementation of a queue (link list data structure) and uses context-switching (concurrent package from lab 3), to switch the process out (process blocked) when lock is not available, and add the process back to the queue to run when the lock becomes available. A spinlock is useful when the critical section is very short and the overhead of a blocking lock, putting a process to sleep and waking it up again, costs more than looping and wasting a few CPU cycles (short critical section). 

The concurrency package created in the concurrency lab were extended and used to create multiple locks that ensure mutual exclusion using lock and unlock functions. I used the process blocked function from _ 3140.s to help implement blocking lock. When a process attempts to acquire a lock but has to block because some other process holds the lock, process _ blocked() is called, which saves the state of the current process and executes a context switch (process _ select() with non-zero argument). Both locks implement mutual exclusion, ensuring that only one process can run their critical section at a time, by the methods explained above. Spinning locks ensure safety by using atomic actions to acquire the lock and if the lock is already held by another process will wait and attempt to grab the lock when it is unlocked. Progress is ensured as the process will spin until it gets the freed lock, ensuring that there will always be a process that will get the lock and run their critical section unless there are no processes in need of the lock. Spinning, however, does not ensure fairness as the process that was spinning the longest may not be the next process to obtain the lock. On the other hand, blocking locks implement all of safety, progress, and fairness. Safety is similarly ensured through atomic operations while progress is ensured due to the blocked processes being awakened to acquire the lock once it has been release.

## Real-time scheduling
The purpose of this lab is to implement aperiodic real time scheduling algorithm, Earliest Deadline Scheduler (EDF). This scheduling algorithm depends on dynamic priority, arrival/request time ri and absolute deadline di. Preemption (context switching) is necessary for optimality, which minimizes average wait time, but also reduces lateness. Tasks that arrive with earlier deadlines preempt (switch out) tasks with later deadlines, then switch back in after high priority tasks finish execution. For part 1 of this lab, a real time clock was implemented. All times are relative to the point which process _ start() is called.  Different timer (PIT 1 instead _ of PIT _ 0) was used to generate interrupts every millisecond and update our current time global variable. For part 2 of the lab, a EDF scheduling algorithm which selects the job with the earliest absolute deadline provided that it is ready to start was implemented.
